#!/usr/bin/env python

import os
import sys
import httplib
import time
import socket
from urlparse import urlparse

# We need to retrieve the reactor parameter passed to vmsagent. The latest
# vmsagent passes the parameter via an environment variable. Older vmsagents
# provide a parameter parsing library. We assume the latest agent and fall back
# to the older agents.
try:
    reactor = os.environ['VMS_reactor']
except KeyError:
    sys.path.append('/etc/gridcentric/common')
    try:
        import common
    except ImportError:
        # We're probably using the latest vmsagent but a reactor parameter
        # wasn't passed in to this clone for whatever reason (perhaps testing).
        reactor = None
    else:
        data = common.parse_params()
        # In the oldest vmsagent, parse_params returns a dict. In more recent
        # agents, parse_params returns an object.
        if not isinstance(data, dict):
            data = data.get_dict()
        reactor = data.get('reactor')

if reactor:
    rest_time = 0.01 # Start at 10ms.

    while True:
        try:
            url = urlparse(reactor)
            # The reactor param could either be an ip or a full
            # url. If it's just an ip, the scheme and netloc will be
            # empty and the path will contain the ip. In this case, we
            # patch up the urlparse resulting object with the infered
            # scheme.
            if url.scheme == '' and url.netloc == '':
                url.scheme = 'http'
                url.netloc = url.path

            if url.scheme == 'https':
                conn = httplib.HTTPSConnection(url.netloc)
            elif url.scheme == 'http':
                conn = httplib.HTTPConnection(url.netloc)
            else:
                raise ValueError("Unknown scheme %s in reactor param" % url.scheme)

            conn.request("POST", "/v1.0/register", "", {})
            resp = conn.getresponse()
            if resp.status == 200:
                break
        except socket.error:
            pass

        # If we were not successful, do an exponential backoff,
        # but keep retrying every minute until we are successful.
        time.sleep(rest_time)
        if rest_time < 60.0:
            rest_time = (rest_time * 1.5)
