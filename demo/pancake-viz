#!/usr/bin/env python

import os
import sys
import time
import subprocess
import getopt
import threading
import math

from gridcentric.pancake.apiclient import PancakeApiClient

api_server = "http://localhost:8080"
password = None
dryrun = False
interval = 1.0
factor = 10.0

def usage():
    print "usage: pancake-demo < -h|--help | [options] command >"
    print "This tool requires 'gource' to be installed."
    print ""
    print "Optional arguments:"
    print "   -h, --help             Display this help message"
    print ""
    print "   -a, --api=             The API url (default is %s)." % api_server
    print ""
    print "   -p, --password=        The password used to connect to the API."
    print ""
    print "   -d, --dryrun           Just print the log."
    print ""
    print "   -f, --factor=          The active scaling factor."
    print ""
    print "   -i, --interval=        The update interval (in seconds)."

opts, args = getopt.getopt(sys.argv[1:], 
        "ha:p:df:i:", ["help","api_server=","password=","dryrun","factor=","interval="])

for o, a in opts:
    if o in ('-h', '--help'):
        usage()
        sys.exit(0)
    elif o in ('-a', '--api'):
        api_server = a
    elif o in ('-p', '--password'):
        password = a
    elif o in ('-d', '--dryrun'):
        dryrun = True
    elif o in ('-f', '--factor'):
        factor = float(a)
    elif o in ('-i', '--interval'):
        interval = float(a)

MANAGER_TYPE        = "manager"
ACTIVE_TYPE         = "active"
INACTIVE_TYPE       = "inactive"
DECOMMISSIONED_TYPE = "decommissioned"
COLOR_MAP = { \
    MANAGER_TYPE        : "FF0000",
    ACTIVE_TYPE         : "00FF00",
    INACTIVE_TYPE       : "00FF00",
    DECOMMISSIONED_TYPE : "008800",
    }

def query_state(client):
    # Just grab the list of managers.
    managers = client.list_managers_active()

    # Build a map of service states.
    services = {}
    service_list = client.list_managed_services()
    for service in service_list:
        if service == "api":
            continue

        ip_map = {}
        ips = client.list_service_ips(service)
        try:
            info = client.get_service_info(service)
            active = info["connections"]
            metrics = info["metrics"]
        except:
            active = []
            metrics = { }

        try:
            # Compute the number of "users" this service will have.
            users = int(math.ceil(float(metrics["active"]) * len(ips) / factor))
        except:
            users = 1

        for ip in ips:
            if ip in active:
                ip_map[ip] = ACTIVE_TYPE
            else:
                ip_map[ip] = INACTIVE_TYPE

        for ip in active:
            if not(ip in ips):
                ip_map[ip] = DECOMMISSIONED_TYPE

        # Save the final ip_list.
        services[service] = ip_map

    return managers, services, users

# Global cached state.
managers_cache = []
services_cache = {}

def make_name(service, name):
    if service:
        return "%s/%s" % (service, name)
    else:
        return "%s" % name

def add_entry(output, service, name, node_type):
    output.write("%d|pancake|A|%s|%s\n" % \
        (0, make_name(service, name), COLOR_MAP[node_type]))
    output.flush()

def delete_entry(output, service, name, node_type):
    output.write("%d|pancake|D|%s|%s\n" % \
        (0, make_name(service, name), COLOR_MAP[node_type]))
    output.flush()

def change_entry(output, service, name, node_type):
    output.write("%d|pancake|M|%s|%s\n" % \
        (0, make_name(service, name), COLOR_MAP[node_type]))
    output.flush()

def active_entry(output, service, name, node_type, user_number):
    output.write("%d|%s%d|M|%s|%s\n" % \
        (0, service, user_number, make_name(service, name), COLOR_MAP[node_type]))
    output.flush()

def generate_log(output, managers, services, users):
    global managers_cache
    global services_cache
    active = []

    for manager in managers:
        if not(manager in managers_cache):
            add_entry(output, None, manager, MANAGER_TYPE)

    for manager in managers_cache:
        if not(manager in managers):
            delete_entry(output, None, manager, MANAGER_TYPE)

    for service in services:
        if not(service in services_cache):
            curr = services[service]
            for ip in curr:
                add_entry(output, service, ip, curr[ip])

        else:
            curr = services[service]
            cache = services_cache[service]

            for ip in curr:
                if not(ip in cache):
                    add_entry(output, service, ip, curr[ip])
                elif cache[ip] != curr[ip]:
                    change_entry(output, service, ip, curr[ip])

            for ip in cache:
                if not(ip in curr):
                    delete_entry(output, service, ip, cache[ip])

            # We can't really change nodes in the middle of the visualization,
            # so instead we just do a modification to all the active nodes.
            for ip in curr:
                if curr[ip] != INACTIVE_TYPE:
                    active.append(ip)

    if len(active) > 0 and users > 0:
        current = 0
        for user in range(0, users):
            current += 1
            ip = active[current % len(active)]
            active_entry(output, service, ip, curr[ip], user)

    for service in services_cache:
        if not(service in services):
            cache = services_cache[service]
            for ip in cache:
                delete_entry(output, service, ip, cache[ip])

    # Save the new state as our cache.
    managers_cache = managers
    services_cache = services

if dryrun:
    # Open stdout.
    output = sys.stdout
else:
    # Open our gource process.
    gource = subprocess.Popen(\
        ["gource", "-w", "--realtime", 
         "--log-format", "custom", 
         "--user-scale", "0.5",
         "--max-user-speed", "20",
         "--hide", "date",
         "--user-image-dir", os.path.dirname(__file__),
         "--default-user-image", os.path.join(os.path.dirname(__file__), "user.png"),
         "--highlight-dirs",
         "--font-size", "14",
         "--file-idle-time", "0",
         "-"], 
         stdin=subprocess.PIPE)
    output = gource.stdin

# Connect to the API.
client = PancakeApiClient(api_server, password)

def update():
    while True:
        # Query state.
        managers, services, users = query_state(client)

        # Generate differential log.
        generate_log(output, managers, services, users)

        # Wait.
        time.sleep(interval)

if dryrun:
    update()
else:
    update_thread = threading.Thread(target=update)
    update_thread.daemon = True
    update_thread.start()
    gource.wait()
