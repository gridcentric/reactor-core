#!/usr/bin/env python 

import socket
import threading
import logging
import json

from pyramid.response import Response
from paste.httpserver import serve

from gridcentric.pancake import log

from gridcentric.pancake.endpoint import Endpoint

from gridcentric.pancake.manager import ScaleManager
from gridcentric.pancake.manager import locked

from gridcentric.pancake.config import ManagerConfig
from gridcentric.pancake.config import EndpointConfig

from gridcentric.pancake.api import PancakeApi
from gridcentric.pancake.api import connected
from gridcentric.pancake.api import authorized
from gridcentric.pancake.api import authorized_admin_only

import gridcentric.pancake.ips as ips

import gridcentric.pancake.zookeeper.iptables as zk_iptables
import gridcentric.pancake.zookeeper.config as zk_config
import gridcentric.pancake.zookeeper.paths as paths

class APIEndpoint(Endpoint):
    def __init__(self, scale_manager):
        self.scale_manager = scale_manager
        Endpoint.__init__(self, "api", self.api_config(), scale_manager)

    def api_config(self, config=None):
        # Read the configuration.
        api_path = paths.endpoint("api")
        if config == None:
            config = EndpointConfig(self.scale_manager.zk_conn.read(api_path))
        api_config = EndpointConfig(str(config))

        # Update basic information.
        url = "http://api.%s" % self.scale_manager.domain
        api_config._set("endpoint", "url", url)
        api_config._set("endpoint", "port", "8080")
        api_config._set("scaling", "url", url)

        # Update the static IPs in the configuration.
        addresses = self.scale_manager.zk_conn.list_children(paths.manager_ips())
        addresses.sort()
        address_str = ",".join(addresses)
        api_config._set("endpoint", "static_instances", address_str)

        if not(api_config._is_clean()):
            # Save the config if it was changed.
            self.scale_manager.zk_conn.write(paths.endpoint("api"), str(api_config))

        return api_config

    def update_config(self, config_str):
        new_config = EndpointConfig(config_str)
        Endpoint.update_config(self, str(self.api_config(new_config)))

class AutoScaleManager(ScaleManager):
    def __init__(self, zk_servers):
        ScaleManager.__init__(self, zk_servers)

        # The implicit API endpoint.
        self.api_endpoint = None

    def start_params(self):
        # Parameters passed to guests launched.
        return {"reactor" : "api.%s" % self.domain}

    @locked
    def setup_iptables(self, managers=[]):
        hosts = []
        hosts.extend(managers)
        for host in self.zk_servers:
            if not(host) in hosts:
                hosts.append(host)
        zk_iptables.setup(hosts, extra_ports=[8080])

    @locked
    def manager_register(self, config_str=''):
        # Ensure that the default loadbalancers are available.
        new_config = ManagerConfig(config_str)
        new_config._set("manager", "loadbalancer", "dnsmasq,nginx")
        ScaleManager.manager_register(self, str(new_config))

    @locked
    def serve(self):
        # Perform normal setup.
        super(AutoScaleManager, self).serve()

        # Make sure we've got our IPtables rocking.
        self.setup_iptables(self.zk_conn.watch_children(
            paths.manager_configs(), self.setup_iptables))

        # Create the API endpoint.
        if not(self.api_endpoint):
            self.api_endpoint = APIEndpoint(self)

        # Ensure it is being served.
        if not(self.api_endpoint.name in self.endpoints):
            self.create_endpoint(self.api_endpoint.name)

    @locked
    def create_endpoint(self, endpoint_name):
        if endpoint_name == "api":
            logging.info("API endpoint found.")

            # Create the API endpoint object.
            endpoint = APIEndpoint(self)
            self.add_endpoint(endpoint, endpoint_path=paths.endpoint(endpoint.name))
        else:
            # Create the standard endpoint.
            super(AutoScaleManager, self).create_endpoint(endpoint_name)

    @locked
    def remove_endpoint(self, endpoint_name, unmanage=False):
        super(AutoScaleManager, self).remove_endpoint(endpoint_name, unmanage=unmanage)

        # We don't allow users to remove the API endpoint,
        # so whenever it's gone it's simply recreated.
        if endpoint_name == "api":
            self.create_endpoint(endpoint_name)

    @locked
    def reload_domain(self, domain):
        super(AutoScaleManager, self).reload_domain(domain)
        if self.api_endpoint:
            # Make sure that the API endpoint reloads appropriately.
            self.api_endpoint.api_config()

class PancakeAutoApi(PancakeApi):
    def __init__(self, zk_servers):
        self.manager_running = False
        PancakeApi.__init__(self, zk_servers)

        self.config.add_route('api-servers', '/reactor/api_servers')
        self.config.add_view(self.set_api_servers, route_name='api-servers')

        # Check the endpoint.
        self.check(zk_servers)

    @connected
    @authorized_admin_only
    def set_api_servers(self, context, request):
        """
        Updates the list of API servers in the system.
        """
        if request.method == 'POST':
            api_servers = json.loads(request.body)['api_servers']
            logging.info("Updating API Servers.")
            self.reconnect(api_servers)
            return Response()
        elif request.method == 'GET':
            return Response(body=json.dumps({ "api_servers" : self.zk_servers }))
        else:
            return Response(status=403)

    def start_manager(self, zk_servers):
        zk_servers.sort()
        self.zk_servers.sort()
        if self.zk_servers != zk_servers:
            self.stop_manager()

        if not(self.manager_running):
            self.manager = AutoScaleManager(zk_servers)
            self.manager_thread = threading.Thread(target=self.manager.run)
            self.manager_thread.daemon = True
            self.manager_thread.start()
            self.manager_running = True

    def stop_manager(self):
        if self.manager_running:
            self.manager.clean_stop()
            self.manager_thread.join()
            self.manager_running = False

    def check(self, zk_servers):
        is_local = ips.any_local(zk_servers)

        if not(is_local):
            # Ensure that Zookeeper is stopped.
            zk_config.ensure_stopped()
            zk_config.check_config(zk_servers)

        else:
            # Ensure that Zookeeper is started.
            logging.info("Starting Zookeeper.")
            zk_config.check_config(zk_servers)
            zk_config.ensure_started()

        # NOTE: We now *always* start the manager. We rely on the user to
        # actually deactivate it or set the number of keys appropriately when
        # they do not want it to be used to power endpoints.
        self.start_manager(zk_servers)

    def reconnect(self, zk_servers):
        # Check that we are running correctly.
        self.check(zk_servers)

        # Call the base API to reconnect.
        PancakeApi.reconnect(self, zk_servers)

def main():
    log.configure(logging.DEBUG, "/var/log/reactor.log")

    try:
        zk_servers = zk_config.read_config()
    except:
        zk_servers = []
    if len(zk_servers) == 0:
        zk_servers = ["localhost"]

    app = PancakeAutoApi(zk_servers)
    serve(app.get_wsgi_app(), host='0.0.0.0')

if __name__ == "__main__":
    main()
